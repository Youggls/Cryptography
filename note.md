## 1 现代密码学基本原则

### 1.1 现代密码学的三个基本原则

定义、假设、证明

- 形式化的**定义**：包括精确的数学模型和安全性定义
  - 安全加密的定义：如果没有敌手能够从密文中计算任何关于明文的函数，则加密方案是安全的
  - 任何安全定义的通用形式：如果特定的敌手不能完成特定的攻破，则给定任务的一个密码学方案是安全的

- 精确的**假设**依赖：所构造方案的安全性依赖于某个假设，该假设需要精确且无歧义

- 严格的安全**证明**：符合上述两个原则的基础上，具备严格的安全证明

考**填空题**

## 2 无条件安全/计算安全

### 2.1 完善保密

- 威胁模型-攻击场景
  - 唯密文攻击：敌手只能观察到一个或多个密文，并试图确定相应的明文
  - 已知明文攻击：敌手已知一个或多个使用相同密钥加密的明文/密文对，并试图确定其他密文对应的明文
  - 选择明文攻击：敌手能够选择明文，并得到相应的密文，并试图确定目标密文对应的明文
  - 选择密文攻击：敌手能够选择密文得到相应的明文，并试图确定其他密文对应的明文
  
- 完善保密：无论敌手是否已知有关明文的先验信息，密文都不应泄露任何有关明文的其他信息（唯密文攻击，单个密文）
  - 计算能力：无限，无条件安全
  - 攻击场景：唯密文攻击
  - 背景知识：明文的概率分布
  
- 完善保密数学语言：
  - 一个对称密钥加密体制可以由明文空间 $\mathcal M$，密文空间 $\mathcal C$ 和算法 $(Gen, Enc, Dec)$ 组成
    - $Gen$ 密钥生成算法：输入安全参数 $\lambda$ 输出密钥 $k$，$k\larr Gen(\lambda)$
    - $Enc$ 加密算法：输入密钥 $k$ 和明文 $m\in \mathcal M$ 输出密文 $c$，$c\larr Enc_k(m)$
    - $Dec$ 解密算法：输入密钥 $k$ 和密文 $c$ 输出明文 $m$ 或错误，$m:=Dec_k(c)$
  - 完善保密的正确定义：存在一个明文空间为 $\mathcal M$ 密文空间为 $\mathcal C$ 的加密方案 $\Pi=(Gen,Enc,Dec)$，如果对 $\mathcal C$ 上任意的概率分布，任意明文 $m \in \mathcal M$ 和任意密文 $c \in \mathcal C(Pr[C=c]>0)$ 均有 $Pr[M=m|C=c]=Pr[M=m]$。则称 $\Pi$ 是完善保密加密。
  
- 一次一密

  - 定义

    - 明文空间、密文空间和密钥空间均为 $\{0, 1\}^l$
    - 密钥生成算法 $Gen$ 从 $\mathcal K = \{0, 1\}^l$ 中根据均匀分布选择一个二进制比特串作为密钥
    - 加密算法 $Enc$ ：给定密钥 $k\in \{0,1\}^l$ 和明文 $c\in \{0,1\}^l$，算法被定义为 $Enc_k(m)=m\oplus k$
    - 解密算法 $Dec$ ：给定密钥 $k\in \{0,1\}^l$ 和明文 $c\in \{0,1\}^l$，算法被定义为 $Dec_k(c)=c\oplus k$
    - 正确性：对所有的 $m\in \mathcal M$ 和由 $Gen$ 输出的 $k$ 均有 $Dec_k(Enc_k(m))=(m\oplus k)\oplus k=m\oplus k \oplus k = m$

  - 证明是完善保密加密：

    - 选定 $\mathcal M$ 上的任意纷纷内部，任意一个明文 $m\in \mathcal M$ 和密文 $c \in \mathcal C$，$\Pi$ 均有

      $Pr[C=c|M=m]=Pr[M\oplus K=c | M=m]=Pr[m\oplus K=c]=Pr[K=m\oplus c]=2^{-l}$

    - 根据全概率公式可得

      $Pr[C=c]=\sum_{m \in \mathcal M} Pr[C=c|M=m]\cdot Pr[M=m]=2^{-l}\sum_{m\in \mathcal M}\cdot Pr[M=m]=2^{-l}$

    - 故有 $Pr[C=c|M=m]=Pr[C=c]$，根据之前的引理，定理得证。

  - 一次一密下的移位加密也是完善保密

- 一次一密的缺陷

  如果存在多个由相同密钥加密所得的一次一密方案的密文，明文消息 $m$ 和 $m'$ 用同样一个密钥 $k$ 进行加密，敌手得到 $c=m\oplus k\ \ \ c'=m'\oplus k$

  那么可以计算出 $c\oplus c'=(m\oplus k)\oplus (m' \oplus k) = m \oplus m'$

  虽然两条消息看起来不重要，但是泄露了关于明文消息的信息

  如果消息明文具有一定特殊分布，获得足够多由相同密钥加密所得的密文，可以攻破一次一密。


###  2.2 渐进方法的计算安全如何定义

- 计算安全：我们希望敌手不能在合理的时间内以任何合理的成功概率攻破方案。

- 渐进安全：

  - 希望通过敌手的运行时间以及成功概率视为某个参数（安全参数 $\lambda$）的函数，对一个给定密码学的方案的安全性进行量化，仅当安全参数 $\lambda$ 足够大时才保证安全。
  - 一般形式：如果每个**概率多项式时间**敌手只能以**可忽略的概率**攻破一个方案，那么该方案是安全的

- 概率多项式时间：算法的时间复杂度为多项式级

  称 $t_A: \{0,1\}^* \rarr \mathbb N$ 为算法 A 的时间复杂度，如果对于任意输入 $x\in \{0,1\}^*$，算法 A 此前好在 $t_A(x)$ 个步骤后终止。

  如果 $t_A=poly(|A|)$，那么称 A 为多项式时间算法，如果 A 同时是一个概率算法，那么 A 是概率多项式时间算法。

### 2.3 例题

- 例 1：什么条件下的维吉尼亚（置换、移位）加密是完善保密加密

  一次一密下

- 例 2：存在完善保密的公钥加密方案吗？

  不存在，即使是一次一密

- 例 3：从计算能力的角度，我们一般考虑怎样的敌手？、

  概率多项式时间（PPT）

- 例 4：如果 $\epsilon(\lambda)$ 是可忽略函数，那么对于任意多项式 $poly$，$poly(\lambda)\cdot\epsilon(\lambda)$ 也是可忽略函数？

  是可忽略函数。反之如果 $poly(\lambda)\cdot\epsilon(\lambda)$ 不是，两者肯定也都不是。

## 3 归约证明

### 3.1 例题

- 例 1：”方案 Y 的安全性基于假设 X“是什么意思？

  答：如果假设 X 成立，那么方案 Y 安全。或如果方案 Y 不安全，那么假设 X 不成立

- 例 2：如何用规约的方法证明方案 Y 的安全性？

  答：利用破解方案 Y 的有效算法构造令假设 X 不成立的有效算法，用于说明”如果方案 Y 不安全，那么假设 X 不成立“，然而假设 X 是成立的，所以方案 Y 安全。

## 4 伪随机性

### 4.1 什么是伪随机性

伪随机性指的是比特串的分布特性：$D$ 为长度 $l$ 的串的分布，如果长度为 $l$ 的串均匀分布与分布 $D$ 在概率多项式时间内不可区分，则称 $D$ 有伪随机性。

### 4.2 选择明文攻击的安全性

给定对称密钥加密体制 $\Pi=(Gen,Enc,Dec)$ 和敌手 $\mathcal A$，其选择铭文攻击条件下的不可区分性 (IND-CPA) 实验定义为：

- CPA 不可区分性实验 $Privk^{cpa}_{\mathcal A,\Pi}(\lambda)$

  - 挑战者运行 $Gen(\lambda)$ 生成一个密钥

  - 挑战者给定输入 $\lambda$ 给 $\mathcal A$，$\mathcal A$ 可以访问预言机 $Enc_k(\cdot)$，输出一对长度相等的消息 $m_0$ 和 $m_1$ 给挑战者

  - 挑战者选择一个随机比特 $b\larr\{0,1\}$，计算挑战密文 $c\larr Enc_k(m_b)$ 并发送给 $\mathcal A$

  - $\mathcal A$ 可以继续访问 $Enc_k(\cdot)$，输出一个比特 $b'$

  - 如果 $b=b'$ 实验输出 1，否则输出 0

- 定义：如果对于所有概率多项式时间敌手 $\mathcal A$，存在一个可忽略函数 $negl$ 使得：

  $Pr[Privk^{cpa}_{\mathcal A,\Pi}(\lambda)=1]\leq1/2+negl(\lambda)$

  则称 $\Pi$ 具备选择明文攻击条件下的不可区分性（IND-CPA）

  - 如果方案是确定加密($Enc$ 是确定算法)，必然不满足 IND-CPA

    敌手在产生不同的 $m_0$ 和 $m_1$ 后，计算得到 $c_0\larr Enc_k(m_0)$ 和 $c_1\larr Enc_k(m_1)$

    在得到挑战密文 $c$ 之后，进行比较，如果 $c=c_0$ 输出 0，否则输出 1

    此时概率为 1

### 4.3 伪随机函数

#### 4.3.1 伪随机数生成器

伪随机数生成器是一个确定多项式时间算法，用于将一个均匀随机选取的长度为 $\lambda$ 的段种子扩展为长度为 $l(\lambda)$ 的伪随机输出。

定义：确定多项式时间算法 $G:\{0,1\}^{\lambda}\rarr\{0,1\}^{l(\lambda)}$ 是伪随机数生成器，如果其满足

- 扩展性：对于每个 $\lambda$ 而言，满足 $l(\lambda) > \lambda$

- 伪随机性：对于所有概率多项式时间区分器 $D：\{0,1\}^{\lambda}\rarr\{0,1\}$ 而言，存在一个可忽略函数 $negl$ 使得：

  $|Pr(D(r)=1)-Pr(D(G(s)))=1|\leq negl(\lambda)$

  其中 $r$ 在 $\{0,1\}^{l(\lambda)}$ 上均匀随机选取，种子 $s$ 在 $\{0,1\}\lambda$ 上均匀随机选取

#### 4.3.2 伪随机函数

令 $F:\{0,1\}^*\times\{0,1\}^*\rarr \{0,1\}^*$ 是有效的、长度保留的（$|F_k(x)|=|x|$）、带密钥的函数，称 $F$ 是一个伪随机函数，如果其满足对所有概率多项式时间区分器 $\mathcal D$ 而言存在一个可忽略函数 $negl$ 使得

 $|Pr[\mathcal D^{F_k(\cdot)}(\lambda)=1]-Pr[\mathcal D^{f(\cdot)}(\lambda)=1]|\leq negl(\lambda)$

其中，$k$ 在 $\{0,1\}^\lambda$ 上均匀随机选取，函数 $f$ 在 $Func_k=\{f|f:\{0,1\}^\lambda\rarr \{0,1\}^\lambda\}$ 上均匀随机选取

#### 4.3.3 伪随机函数：IND-CPA 方案构造

消息长度为 $\lambda$ 的定长对称密钥加密方案 $\Pi=(Gen,Enc,Dec)$

- $F$ 是一个伪随机函数
- 密钥生成算法：均匀随机地选取 $k\larr \{0,1\}^\lambda$ 作为密钥并输出
- 加密算法：给定密钥 $k\in\{0,1\}^\lambda$ 和明文 $m\in \{0,1\}^\lambda$，均匀随机地选择 $r\larr \{0,1\}^\lambda$，定义输出：$Enc_k(m)=r||F_k(r)\oplus m$
- 解密算法：给定密钥 $k\in\{0,1\}^\lambda$ 和密文 $c=r||s$，定义输出：$Dec_k(c)=F_k(r)\oplus s$

证明：如果 $F$ 是一个伪随机函数，那么方案 $\Pi$ 具备选择明文攻击下的不可区分性

- 令 $\mathcal A$ 为一个 PPT 敌手，定义 $\epsilon(\lambda)=Pr[Privk^{cpa}_{\mathcal A,\Pi}(\lambda)=1]-1/2$
- 构造一个区分器 $\mathcal D^{\mathcal O(\cdot)}$，其可以访问函数的预言机 $\mathcal O:\{0,1\}^\lambda\rarr \{0,1\}^\lambda$
  - 运行 $\mathcal A$，无论何时 $\mathcal A$  向加密预言机发出关于 $m$ 的查询，用下述方法应答：
    - 均匀随机地选择 $r\larr \{0,1\}^\lambda$，询问获得 $s'\larr\mathcal O(r)$
    - 返回密文 $r||s'\oplus m$
  - 当 $\mathcal A$ 处获得一对消息 $m_0, m_1\in\{0,1\}^\lambda$ 时，随机选择一个比特 $b$
    - 均匀随机地选择  $r\larr \{0,1\}^\lambda$，询问获得 $s'\larr \mathcal O(r)$
    - 返回挑战密文 $r||s'\oplus m_b$
  - $\mathcal A$ 最终输出 $b'$，如果 $b=b'$，则输出 1，否则输出 0
- 构造方案 $\Pi'=(Gen',Enc',Dec')$，使用均匀随机选取的函数 $f\in Func_\lambda$ 代替方案 $\Pi$ 中 $Enc$ 的 $F_k$，其余构造均相同。
- 在实验 $Privk^{cpa}_{\mathcal A,\Pi'}(\lambda)$ 中
  - $\mathcal A$ 最多向加密预言机询问 $q(\lambda)$ 次，$q$ 为多项式
  - 关于 $m$ 询问的应答为 $r||f(r)\oplus m$ 其中均匀随机选择 $r\larr \{0,1\}^\lambda$
  - 令 $r_c$ 为生成挑战密文 $r_c||f(r_c)\oplus m_b$ 时的随机串
  - 如果 $r_c$ 曾被加密预言机用作回答，则 $\mathcal A$ 可以正确区分挑战密文，该事件发生的概率最多为 $q(\lambda)/2^\lambda$
  - 如果 $r_c$ 未曾被加密预言机用作回答，则 $f(r_c)\oplus m_b$ 完全随机，在这种情况下，$\mathcal A$ 可以正确区分挑战密文的概率为 $1/2$
  - 所以 $Pr[Privk^{cpa}_{\mathcal A,\Pi'}=1]\leq q(\lambda)/2^\lambda\cdot1+1\cdot1/2=1/2+q(\lambda)/2^\lambda$
- 观察给定不同预言机 $\mathcal O$ 时 $\mathcal D$ 的输出，证明 $\mathcal D$ 的有效性
- 当预言机为一个在 $Func_\lambda$ 上均匀随机选取的函数 $f$ 时
  - $\mathcal A$ 在所见内容的分布与在其实验 $Privk^{cpa}_{\mathcal A, \Pi'}(\lambda)$ 中完全相同
  - 此时 $Pr[\mathcal D^{f(\cdot)}(\lambda)=1]=Pr[Privk^{cpa}_{\mathcal A, \Pi'}=1]\leq1/2+q(\lambda)/2^\lambda$
- 当预言机为一个伪随机函数 $F_k$ 时，其中 $k$ 在 $\{0,1\}^\lambda$ 上均匀选取
  - $\mathcal A$ 在所见内容分布与其在实验 $Privk^{cpa}_{\mathcal A, \Pi}(\lambda)$ 中完全相同（其所见密文均为 $Enc_k(\cdot)$ 加密所得）
  - 此时 $Pr[\mathcal D^{F_k(\cdot)}(\lambda)=1]=Pr[Privk^{cpa}_{\mathcal A,\Pi}(\lambda)=1]=1/2+\epsilon(\lambda)$
- 因此，$|Pr[\mathcal D^{F_k(\cdot)}(\lambda)=1]-Pr[\mathcal D^{f(\cdot)}(\lambda)]|\geq \epsilon(\lambda)-q(\lambda)/2^\lambda$
- 然而并不存在有效的 $\mathcal D$，所以 $\epsilon(\lambda)-q(\lambda)/2^\lambda$ 可忽略
- 又因为可忽略 $q(\lambda)/2^\lambda$，所以 $\epsilon(\lambda)$ 可忽略，定理得证

#### 4.3.4 伪随机置换与伪随机函数

- 定义：令 $F:\{0,1\}^*\times\{0,1\}^*\rarr\{0,1\}^*$ 是有效的带密钥的置换，称 $F$ 是一个**伪随机置换**如果其满足对所有**概率多项式时间**区分器 $\mathcal D$ 而言存在一个可忽略函数 $negl$，使得：

  $|Pr[\mathcal D^{F_k(\cdot)}=1]-Pr[\mathcal D^{f(\cdot)}(\lambda)]|\leq negl(\lambda)$

  其中 $k$ 在 $\{0,1\}^\lambda$ 上均匀随机选取， $f$ 是从 $\lambda$ 比特串置换的集合中均匀随机选择的

- **强伪随机置换**定义：令 $F:\{0,1\}^*\times\{0,1\}^*\rarr\{0,1\}^*$ 是有效的带密钥的置换，称 $F$ 是一个**伪随机置换**如果其满足对所有**概率多项式时间**区分器 $\mathcal D$ 而言存在一个可忽略函数 $negl$，使得：

  $|Pr[\mathcal D^{F_k(\cdot),F^{-1}_k(\cdot)}=1]-Pr[\mathcal D^{f(\cdot),f^{-1}(\cdot)}(\lambda)]|\leq negl(\lambda)$

  其中 $k$ 在 $\{0,1\}^\lambda$ 上均匀随机选取， $f$ 是从 $\lambda$ 比特串置换的集合中均匀随机选择的

#### 4.3.5 利用伪随机函数/置换构造的加密模式

- ECB 模式

  ![image-20211216125604166](密码学复习.assets/image-20211216125604166.png)

  - 确定性加密
  - 无法满足多次加密不可区分性，更不满足 IND-CPA

- CBC 模式

  ![image-20211215212159855](密码学复习.assets/image-20211215212159855.png)

  - $F$ 是一个伪随机置换，CBC 模式满足 IND-CPA
  - 改变了前面 IND-CPA 构造中密文长度为明文两倍的缺陷
  - CBC 模式加密需要以此进行，无法实现并行处理

- OFB 模式

  ![image-20211216130032823](密码学复习.assets/image-20211216130032823.png)

  - $F$ 可以是一个伪随机函数，OFB 模式满足 IND-CPA
  - OFB 模式中大量独立于明文的伪随机流可以在预处理阶段计算

- CTR 模式

  ![image-20211216130301208](密码学复习.assets/image-20211216130301208.png)

  - $F$ 可以是一个伪随机函数，CTR 模式满足 IND-CPA
  - CTR 模式可以实现随机访问（只解密第 i 个分组）

### 4.4 例题

- 例 1：$DES$ 扩展函数 $E$ 被定义为输入 $s=b_1b_2...b_{32}$，输出 $E(s)=b_{32}b_1b_2...b_{32}b_{32}b_1$，那么 $E$ 是伪随机数生成器吗？为什么（此时 $\lambda=32$ 扩展因子 $l(\lambda)=3\lambda/2$

  |      |      |      |      |      |      |
  | :--: | :--: | :--: | :--: | :--: | :--: |
  |  32  |  1   |  2   |  3   |  4   |  5   |
  |  4   |  5   |  6   |  7   |  8   |  9   |
  |  8   |  9   |  10  |  11  |  12  |  13  |
  |  12  |  13  |  14  |  15  |  16  |  17  |
  |  16  |  17  |  18  |  19  |  20  |  21  |
  |  20  |  21  |  22  |  23  |  24  |  25  |
  |  24  |  25  |  27  |  27  |  28  |  29  |
  |  28  |  29  |  30  |  31  |  32  |  1   |

  解答思路：观察 $s$ 均匀随机选取时 $E(s)$ 的输出 $w$ 与等长均匀随机串 $r$ 的差别，然后构造区分器 $D$，可以以不忽略的概率区分 $w$ 与 $r$

  - 48 比特串 $w$ 的第 1 比特等于第 47 比特，第 2 比特等于第 48 比特，共有 16 个特定比特重复
  - 如果均匀选择一个 48 比特的串，特定有 16 个特定位置的比特重复的概率最多为 $2^{-16}(2^{-\lambda/2})$
  - 设区分器 $D$，输入为 48 比特的串，检查对应位置比特是否都相等，如果都相等那么输出 1，否则输出 0
  - 这样 $|Pr[D(E(s))=1]-Pr[D(r)=1]|\geq1-2^{-\lambda/2}$，$E$ 显然不是伪随机数生成器

- 例 2：当初始向量 $IV$ 均匀随机选取时，$CBC$ 、$OFB$、$CTR$ 模式满足 $IND-CPA$ 吗？（下图是 $CBC$ 模式）

  ![image-20211215212159855](密码学复习.assets/image-20211215212159855.png)

  满足，但固定初始向量不满足





